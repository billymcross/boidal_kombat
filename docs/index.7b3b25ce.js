function n(n){return n&&n.__esModule?n.default:n}var e;e="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\nin  vec4 agent_out;\nout vec4 frag;\n\nvoid main() {\n  frag = agent_out;\n}";var o;o="#version 300 es\nprecision mediump float;\n#define GLSLIFY 1\n\n// last reported agent (vertex) position/velocity\nin vec4 agent_in;\n\n// texture containing position/velocity of all agents\nuniform sampler2D flock;\n// total size of flock\nuniform float agentCount;\n//resolution\nuniform vec2 resolution;\n//mouse coords\nuniform vec2 mouse;\n\n//thresholds, passed from params\nuniform float cohesionDist;\nuniform float separationDist;\nuniform float alignDist;\n\n//scales for different forces\nuniform float cohesionScale;\nuniform float separationScale;\nuniform float alignScale;\n\n//boolean to diffuse boids\nuniform bool diffuseBoids;\n\n//Main audio level\nuniform float audio;\n\n//Audio scales for each force\nuniform float cohesionAudio;\nuniform float separationAudio;\nuniform float alignAudio;\n\n// newly calculated position / velocity of agent\nout vec4 agent_out;\n\nvec2 cohesion = vec2(0., 0.);\nvec2 separation = vec2(0., 0.);\nvec2 align = vec2(0., 0.);\n\nvec2 acceleration = vec2(0., 0.);\nfloat maxSpeed = .03;\nfloat maxForce = .001;\n\nfloat random(vec2 coeff) {\n  return fract(sin(dot(coeff, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid main() {\n  // the position of this vertex needs to be reported\n  // in the range {-1,1}. We can use the gl_VertexID\n  // input variable to determine the current vertex's\n  // position in the array and convert it to the desired range.\n  float idx = -1. + (float( gl_VertexID ) / agentCount) * 2.;\n\n  // we'll use agent_out to send the agent position and velocity\n  // to the fragment shader, which will render it to our 1D texture.\n  // agent_out is also the target of our transform feedback.\n  agent_out = agent_in;\n\n  if (!diffuseBoids) {\n    // loop through all agents...\n    for( int i = 0; i < int( agentCount ); i++ ) {\n      // make sure the index isn't the index of our current agent\n      if( i == gl_VertexID ) continue;\n\n      // get our agent for comparison. texelFetch accepts an integer\n      // vector measured in pixels to determine the location of the\n      // texture lookup.\n      vec4 agent  = texelFetch( flock, ivec2(i,0), 0 );\n\n      float dist = distance(agent_out.xy, agent.xy);\n\n      if (dist < cohesionDist) {\n        cohesion += agent.xy;\n      }\n\n      if (dist < separationDist) {\n        vec2 diff = (agent_out.xy - agent.xy);\n        separation += diff;\n      }\n\n      if (dist < alignDist) {\n        align += agent.zw;\n      }\n    }\n\n    cohesion = cohesion;\n    cohesion -= agent_out.zw;\n    if (length(cohesion) > maxForce) {\n      cohesion = normalize(cohesion) * maxForce;\n    }\n    cohesion *= -1.;\n    cohesion *= cohesionScale;\n    float cohesionTotalAudio;\n    if (cohesionAudio > 0.) cohesionTotalAudio = audio * cohesionAudio;\n    else cohesionTotalAudio = audio;\n    cohesion *= cohesionTotalAudio;\n\n    separation = separation;\n    separation -= agent_out.zw;\n    if (length(separation) > maxForce) {\n      separation = normalize(separation) * maxForce;\n    }\n    separation *= separationScale;\n    float separationTotalAudio;\n    if (separationAudio > 0.) separationTotalAudio = audio * separationAudio;\n    else separationTotalAudio = audio;\n    separation *= separationTotalAudio;\n\n    align -= agent_out.zw;\n    if (length(align) > maxForce) {\n      align = normalize(align) * maxForce;\n    }\n    align *= alignScale;\n    float alignTotalAudio;\n    if (alignAudio > 0.) alignTotalAudio = audio * alignAudio;\n    else alignTotalAudio = audio;\n    align *= alignTotalAudio;\n\n    acceleration += cohesion + separation + align;\n    agent_out.zw += acceleration;\n  }\n\n  else {\n    agent_out.x = (-1. + (random(agent_out.xy)*2.));\n    agent_out.y = (-1. + (random(agent_out.xy)*2.));\n\n  }\n\n  if (length(agent_out.zw) > (maxSpeed)) {\n    agent_out.zw = normalize(agent_out.zw);\n    agent_out.zw *= (maxSpeed);\n  }\n\n  agent_out.x = agent_out.x + agent_out.z;\n  agent_out.y = agent_out.y + agent_out.w;\n\n  if (agent_out.x > 1.) agent_out.x = -1.;\n  if (agent_out.x < -1.) agent_out.x = 1.;\n  if (agent_out.y > 1.) agent_out.y = -1.;\n  if (agent_out.y < -1.) agent_out.y = 1.;\n\n  // each agent is one pixel. remember, this shader is not used for\n  // rendering to the screen, only to our 1D texture array.\n  gl_PointSize = 1.;\n\n  // report our index as the x member of gl_Position. y is always 0.\n  gl_Position = vec4( idx, .0, 0., 1. );\n}";var t;t="#version 300 es\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\n\nin vec4 agent_out;\n\nuniform float time;\n\nout vec4 color;\nvoid main() {\n\n  color = vec4( abs(agent_out.z / 0.01), 0. , abs(agent_out.w / 0.1), 1. );\n}";var i;i="#version 300 es\n#define GLSLIFY 1\nin vec4 agent;\n\nout vec4 agent_out;\n\nuniform float audio;\n\nvoid main() {\n  gl_PointSize = 2.;\n  gl_Position = vec4( agent.xy, 0., 1. );\n  agent_out = agent;\n}";let a,r,u,f,s,c,l,d,g,m,_,A,T,E,h,p,x,R,F,S,D,v,U=0,b=0;const w=[],y={cohesionDist:.4,separationDist:.1,alignDist:.05,cohesionScale:1,separationScale:1,alignScale:1},L={cohesionAudio:1,separationAudio:1,alignAudio:1};function B(n,e,o=null){let t=a.createShader(a.VERTEX_SHADER);a.shaderSource(t,n),a.compileShader(t);let i=a.getShaderInfoLog(t);""!==i&&console.log(i);const u=a.createShader(a.FRAGMENT_SHADER);a.shaderSource(u,e),a.compileShader(u),i=a.getShaderInfoLog(u),""!==i&&console.log(i);const f=a.createProgram();return a.attachShader(f,t),a.attachShader(f,u),null!==o&&(r=a.createTransformFeedback(),a.bindTransformFeedback(a.TRANSFORM_FEEDBACK,r),a.transformFeedbackVaryings(f,o,a.SEPARATE_ATTRIBS)),a.linkProgram(f),null===o?f:[f,r]}window.onload=function(){const P=document.getElementById("gl");a=P.getContext("webgl2"),P.width=window.innerWidth,P.height=window.innerHeight,window.onmousemove=function(n){U=n.x/P.width*2-1,b=n.y/P.height*2-1,b*=-1},v=!1,window.onkeydown=function(){if(!v){S=new AudioContext;const n=document.getElementById("audioElement"),e=S.createMediaElementSource(n);e.connect(S.destination),D=S.createAnalyser(),D.fftSize=1024,e.connect(D),v=!0}};const X=(new Tweakpane.Pane).addTab({pages:[{title:"Behavior"},{title:"Audio"}]});X.pages[0].addInput(y,"cohesionDist",{min:0,max:.5}),X.pages[0].addInput(y,"separationDist",{min:0,max:.5}),X.pages[0].addInput(y,"alignDist",{min:.02,max:.5}),X.pages[0].addInput(y,"cohesionScale",{min:1,max:30}),X.pages[0].addInput(y,"separationScale",{min:1,max:30}),X.pages[0].addInput(y,"alignScale",{min:1,max:30}),X.pages[1].addInput(L,"cohesionAudio",{min:0,max:10}),X.pages[1].addInput(L,"separationAudio",{min:0,max:10}),X.pages[1].addInput(L,"alignAudio",{min:0,max:10}),function(){const t=B(n(o),n(e),["agent_out"]);f=t[0],r=t[1],a.useProgram(f),c=function(){const n=[];for(let e=0;e<=65536;e+=4)n[e]=2*Math.random()-1,n[e+1]=2*Math.random()-1,n[e+2]=10*Math.random()-2,n[e+3]=10*Math.random()-2;return function(n,e=1,o=a.STATIC_DRAW){const t=a.createBuffer();a.bindBuffer(a.ARRAY_BUFFER,t),a.bufferData(a.ARRAY_BUFFER,n,o);let i=null;if(e>1){i=[t];for(let t=0;t<e;t++){const e=a.createBuffer();a.bindBuffer(a.ARRAY_BUFFER,e),a.bufferData(a.ARRAY_BUFFER,n.byteLength,o),i.push(e)}}return Array.isArray(i)?i:t}(new Float32Array(n),2,a.DYNAMIC_COPY)}(),function(){const n=a.getAttribLocation(f,"agent_in");a.enableVertexAttribArray(n),a.vertexAttribPointer(n,4,a.FLOAT,!1,0,0);const e=a.getUniformLocation(f,"agentCount");a.uniform1f(e,16384),l=a.getUniformLocation(f,"mouse"),a.uniform2f(l,0,0),g=a.getUniformLocation(f,"cohesionDist"),a.uniform1f(g,y.cohesionDist),m=a.getUniformLocation(f,"separationDist"),a.uniform1f(m,y.separationDist),_=a.getUniformLocation(f,"alignDist"),a.uniform1f(_,y.alignDist),A=a.getUniformLocation(f,"cohesionScale"),a.uniform1f(A,y.cohesionScale),T=a.getUniformLocation(f,"separationScale"),a.uniform1f(T,y.separationScale),E=a.getUniformLocation(f,"alignScale"),a.uniform1f(E,y.alignScale),h=a.getUniformLocation(f,"cohesionAudio"),a.uniform1f(h,L.cohesionAudio),p=a.getUniformLocation(f,"separationAudio"),a.uniform1f(p,L.separationAudio),x=a.getUniformLocation(f,"alignAudio"),a.uniform1f(x,L.alignAudio),R=a.getUniformLocation(f,"audio")}()}(),function(){s=B(n(i),n(t)),d=a.getUniformLocation(s,"time");const e=a.getAttribLocation(s,"agent");a.enableVertexAttribArray(e),a.vertexAttribPointer(e,4,a.FLOAT,!1,0,0),F=a.getUniformLocation(s,"audio"),a.useProgram(s)}(),w[0]=a.createTexture(),a.bindTexture(a.TEXTURE_2D,w[0]),a.getExtension("EXT_color_buffer_float"),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.NEAREST),a.texImage2D(a.TEXTURE_2D,0,a.RGBA32F,16384,1,0,a.RGBA,a.FLOAT,null),w[1]=a.createTexture(),a.bindTexture(a.TEXTURE_2D,w[1]),a.getExtension("EXT_color_buffer_float"),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.NEAREST),a.texImage2D(a.TEXTURE_2D,0,a.RGBA32F,16384,1,0,a.RGBA,a.FLOAT,null),u=a.createFramebuffer(),I()};let P=0;function I(){document.getElementById("audioSource");if(P++,window.requestAnimationFrame(I),a.useProgram(f),a.uniform2f(l,U,b),a.uniform1f(g,y.cohesionDist),a.uniform1f(m,y.separationDist),a.uniform1f(_,y.alignDist),a.uniform1f(A,y.cohesionScale),a.uniform1f(E,y.alignScale),a.uniform1f(T,y.separationScale),v){var n=new Uint8Array(D.fftSize);D.getByteTimeDomainData(n),console.log(n[0]),audioValue=parseFloat(n[0]-100),audioValue>=0?a.uniform1f(R,audioValue):a.uniform1f(R,0),a.uniform1f(h,L.cohesionAudio),a.uniform1f(p,L.separationAudio),a.uniform1f(x,L.alignAudio)}a.uniform1i(undefined,y.diffuseBoids),a.bindFramebuffer(a.FRAMEBUFFER,u),a.viewport(0,0,16384,1),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,w[1],0),a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,w[0]),a.bindBuffer(a.ARRAY_BUFFER,c[0]),a.vertexAttribPointer(undefined,4,a.FLOAT,!1,0,0),a.bindBufferBase(a.TRANSFORM_FEEDBACK_BUFFER,0,c[1]),a.beginTransformFeedback(a.POINTS),a.drawArrays(a.POINTS,0,16384),a.endTransformFeedback(),a.bindBufferBase(a.TRANSFORM_FEEDBACK_BUFFER,0,null),a.bindFramebuffer(a.FRAMEBUFFER,null),a.viewport(0,0,a.drawingBufferWidth,a.drawingBufferHeight),a.useProgram(s),a.uniform1f(d,P),a.bindBuffer(a.ARRAY_BUFFER,c[0]),a.drawArrays(a.POINTS,0,16384);let e=c[0];c[0]=c[1],c[1]=e,e=w[0],w[0]=w[1],w[1]=e}
//# sourceMappingURL=index.7b3b25ce.js.map
